<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Document</title>
</head>
<body>
  <script>
  //使用new创建对象
  var obj = new Object();
  console.log(obj);//Object {}


  //添加属性
  obj.name = '鲁班';
  obj.age = '5';
  //添加方法
  obj.info = function(percent){
    console.log(this);
    console.log(obj.name,obj.age,percent);
  }
  //使用对象
  console.log(obj);//{name: "鲁班", age: "5"}
  console.log(obj.name);//鲁班
  obj.info('50%');//{name: "鲁班", age: "5"}来自21行的内容
                  //鲁班 5 50% 来自22行

  // 遗留问题：这种创建方式只是创建了一个单个对象
  //如果我们再要创建对象，只能把重新执行创建步骤

  // 克隆复制的方式创建副本
  function cloneObj(oldObj){
    //创建一个副本
    var newObj = new Object();
    //复制属性和方法
    //就对象是Jason数组，循环遍历的方式来添加到新数组
    for(key in oldObj){
      //key:属性名/方法名 oldObj.key,不可以使用，因为只有属性名才可以用点引用,key是变量
      // newObj[key] = oldObj.key;
      newObj[key] = oldObj[key];
    }
    //把副本返回出来
    return newObj;
  }
  //使用副本(不会受原对象的影响，不会更新变化)
  var p1 = cloneObj(obj);//得到obj对象的副本
  // console.log(p1);//{name: undefined, age: undefined, info: undefined}
  console.log(p1);//{name: "鲁班", age: "5"}
  p1.age = 20;
  console.log(p1);//Object {name: "鲁班", age: 20}

  var p2 = cloneObj(obj);//得到第二个副本
  console.log(p2);//{name: "鲁班", age: "5"}
  p2.age = 32;
  console.log(p2);//{name: "鲁班", age: 32}

  //原对象修改了属性和方法
  obj.sex = '男';
  console.log(obj);//Object {name: "鲁班", age: "5", sex: "男"}
  console.log(p1);//Object {name: "鲁班", age: 20}
  console.log(p2);//Object {name: "鲁班", age: 32}
  </script>
</body>
</html>